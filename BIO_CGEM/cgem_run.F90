!==============================================================================
!   CGEM
!   Info
!   Copyright
!   License
!==============================================================================
subroutine cgem_run(istep,myrank)
  use schism_glbl, only : rkind,nea,idry_e,irange_tr,flx_sf,flx_bt,bdy_frc,&
   & nvrt,kbe,dp,dpe,tr_el,dt,srad,elnode,i34,windx,windy,area,ze,wsett,   &
   & xlon,ylat
  use cgem, only: ws,skipcgem,checkwindrad,sinkwcgem,nf,debug,Which_rad,Which_wind,&
                  PARfac,cgemcoords,cgemlat,cgemlon
  use grid, only: iYrS,START_SECONDS,km

  implicit none

  integer, intent(in) :: istep,myrank
  integer :: itmp1,itmp2,i,m,im,mm,k,nz
  integer :: TC_8
  logical :: is_surface,is_bottom
  real(rkind),parameter :: pi=3.141592653589793_rkind
  real(rkind),parameter :: one80=180._rkind
  real :: x
  real(rkind) :: ff(nf),ff_new(nf),ff_in(km,nf),ff_out(km,nf),dz(km),PAR(km)
  real(rkind) :: fs_in(km),fs_out(km)
  real(rkind) :: Rad, Wind, T, S, d_sfc
  real(rkind) :: lat,lon
  real(rkind), parameter :: cv        = 2.77e14_rkind ! multiplicative factor used
                                             ! to convert from watts/m2 
                                             ! to photons/cm2/sec
                                             ! Morel and Smith (1974)
  external :: cgem_step !, cgem_flux, cgem_sink
  
  !Just say Hi in mirror.out
  if(myrank==0) write(16,*) "In cgem_run: istep,dt=",istep,dt
  !Time in seconds since start of run
  TC_8 = START_SECONDS + istep*int(dt)

  !Range of tracers, first 2 are S,T, then CGEM are next
  itmp1=irange_tr(1,3)
  itmp2=irange_tr(2,3)

  !Loop over elements
  do i=1,nea
    !Skip if element is dry or depth is below a set minimum
    if(idry_e(i)==1) cycle

    !mocsy uses lat, get_solar uses lat/lon
    if(cgemcoords) then
      lon = cgemlon
      lat = cgemlat
    else
    !mocsy/get_solar use degrees east, not negative
      lon = abs(xlon(i)*One80/pi)
      lat = ylat(i)*One80/pi
    endif

    !Number of non-empty layers
    nz = nvrt - kbe(i)
    if(debug.gt.0.and.istep.eq.1.and.i.eq.10) write(6,*) "nvrt,kbe(i),kbe(i)+1",nvrt,kbe(i),kbe(i)+1,nz

    !Set surface and bottom flux, and body forces to zero
    flx_sf(itmp1:itmp2,i)=0.d0
    flx_bt(itmp1:itmp2,i)=0.d0
    bdy_frc(itmp1:itmp2,:,i)=0.d0

    if(Which_rad.eq.1) then
      !Wind/Rad expressions copied directly from cosine.F90
      !Convert Rad from W/m2 to photons/cm2/sec
      Rad = max(sum(srad(elnode(1:i34(i),i)))/i34(i),0.d0)*cv
      !write(6,*) Rad,srad(elnode(1:i34(i),i)),i34(i),cv
    else
      call getSolar( iYrS, TC_8, lon, lat, Rad)
      ! Rad is just above sea surface.
      ! Rad was short wave generated by NRL, multiplied by SWtoPAR: ratio of PAR to
      ! shortwave radiation (hardcoded 4/30/14 to 0.43).
      ! Hardcoded to 0.47 on 2/11/16, Re: Tsubo and Walker, 2005
      ! PARfac is a multiplication factor for testing
      Rad = (0.47*Rad) * PARfac
    endif

    if(Which_wind.eq.1) then
     !Wind/Rad expressions copied directly from cosine.F90
      Wind=sqrt((sum(windx(elnode(1:i34(i),i)))/real(i34(i),rkind))**2.0+(sum(windy(elnode(1:i34(i),i)))/real(i34(i),rkind))**2.0)
    else
      !Set as constant if no wind fluxes available
      Wind = 5.d0 
    endif

    !This will write Wind/Rad for every single timestep, don't run for long or
    !the resulting text file will be enormous.
    if(checkwindrad.eq.1) write(6,*) "Wind,Rad,Minutes,lat,lon",Wind,Rad,istep*int(dt)/60./60.,lat,lon

    !The option to skip cgem is for verifying initial and boundary conditions,
    !  sinking, and loading without cgem complicating the process 
    if(skipcgem.eq.1) then
      !Don't call cgem
    else
      !Call CGEM
      !First, Call the light model
     im = nz 
     do k=kbe(i)+1,nvrt
        !2D array, get values from SCHISM
        ff_in(im,1:nf) = tr_el(itmp1:itmp2,k,i)
        !Define depth of cell
        dz(im) = ze(k,i)-ze(k-1,i)
        im = im-1
     enddo !k

     call call_iop_par(ff_in,nz,TC_8,Rad,dz,lat,lon,PAR)
     if(i.eq.10.and.debug.eq.1) write(6,*) "PAR",PAR
     if(i.eq.10.and.debug.eq.1) write(6,*) "dz",dz
     if(i.eq.10.and.debug.eq.1) write(6,*) "istep,i,nz,nvrt,kbe(i),Rad,Wind,tot_dz",istep,i,nz,nvrt,kbe(i),Rad,Wind,SUM(dz(1:nz))
     !Update schism tracer variables with newly calculated cgem variables
     im = nz 
     do k=kbe(i)+1,nvrt
       T = tr_el(1,k,i)
       S = tr_el(2,k,i)
       ff(1:nf) = tr_el(itmp1:itmp2,k,i)
       d_sfc = -1.*(ze(k-1,i)-ze(nvrt,i))
       if(i.eq.10.and.debug.eq.1) write(6,*) "k,istep=",k,istep
       if(i.eq.10.and.debug.eq.1) write(6,*) i,k,nvrt,d_sfc,T,S,Rad,dt,PAR(im)
       if(i.eq.10.and.debug.eq.1) write(6,*) "ff",ff
       is_surface = .FALSE.
       is_bottom = .FALSE.
       if(im.eq.1) is_surface = .TRUE. 
       if(im.eq.nz) is_bottom = .TRUE.
       call cgem_step(ff,ff_new,dT, S, T, PAR(im), Wind, lat, dz(im), d_sfc, is_surface, is_bottom, Rad, i)
       tr_el(itmp1:itmp2,k,i) = ff_new(1:nf)
       if(i.eq.10.and.debug.eq.1) write(6,*) "ff_new",ff_new
       if(i.eq.10.and.debug.eq.1) write(6,*) "tr",tr_el(itmp1:itmp2,k,i)
       if(i.eq.10.and.debug.eq.1) write(6,*) "d_sfc",d_sfc
       im = im-1
     enddo !k
  endif !end 'if skipcgem'

  !Calculate sinking with our subroutine...
  if(sinkwcgem) then
    do m=itmp1,itmp2
      mm=m-2
      !if the variable sinks...
      if(ws(mm).gt.tiny(x)) then
        !define fs_in     
        im = nz
        do k=kbe(i)+1,nvrt
          !After cgem, tr_el has been updated
          !get column(1:nz) of sinking state_variable ff(mm)
          fs_in(im) = tr_el(m,k,i)
          im = im-1
        enddo !k
        !sink
        call cgem_sink(fs_in,fs_out,ws(mm),nz,dz,dt,i,istep,myrank)
        !update tr
        im = nz
        do k=kbe(i)+1,nvrt
           !update tr_el for ff(mm)(1:nz)
           tr_el(m,k,i) = fs_out(im)
           im = im-1
        enddo !k
      endif!if sinking variable
    enddo !end loop over variables
    !...and set SCHISM sinking rates to zero
      do m=itmp1,itmp2
       wsett(m,:,i) = 0.d0
      enddo
    !...or let SCHISM do the sinking
    else 
      !wsett is settling velocity
      mm = 1                 !cgem tracers are mm=1:nf
      do m=itmp1,itmp2       !schism's are m=itmp1:itmp2
        wsett(m,:,i)= ws(mm) !ws(nf) is cgem sinking array
        mm = mm+1
      enddo
    endif !End 'who does sinking'

  enddo !inea, end loop over elements

return
end subroutine cgem_run
